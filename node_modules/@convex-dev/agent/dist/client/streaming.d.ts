import { type ChunkDetector, type StreamTextTransform, type ToolSet } from "ai";
import type { ProviderOptions, StreamArgs, StreamMessage, TextStreamPart } from "../validators.js";
import type { MessageDoc } from "../component/schema.js";
import type { AgentComponent, RunActionCtx, RunMutationCtx, RunQueryCtx, SyncStreamsReturnValue } from "./types.js";
/**
 * A function that handles fetching stream deltas, used with the React hooks
 * `useThreadMessages` or `useStreamingThreadMessages`.
 * @param ctx A ctx object from a query, mutation, or action.
 * @param component The agent component, usually `components.agent`.
 * @param args.threadId The thread to sync streams for.
 * @param args.streamArgs The stream arguments with per-stream cursors.
 * @returns The deltas for each stream from their existing cursor.
 */
export declare function syncStreams(ctx: RunQueryCtx, component: AgentComponent, args: {
    threadId: string;
    streamArgs: StreamArgs | undefined;
    includeStatuses?: ("streaming" | "finished" | "aborted")[];
}): Promise<SyncStreamsReturnValue | undefined>;
export declare function abortStream(ctx: RunMutationCtx, component: AgentComponent, args: {
    reason: string;
} & ({
    streamId: string;
} | {
    threadId: string;
    order: number;
})): Promise<boolean>;
/**
 * List the streaming messages for a thread.
 * @param ctx A ctx object from a query, mutation, or action.
 * @param component The agent component, usually `components.agent`.
 * @param args.threadId The thread to list streams for.
 * @param args.startOrder The order of the messages in the thread to start listing from.
 * @param args.includeStatuses The statuses to include in the list.
 * @returns The streams for the thread.
 */
export declare function listStreams(ctx: RunQueryCtx, component: AgentComponent, { threadId, startOrder, includeStatuses, }: {
    threadId: string;
    startOrder?: number;
    includeStatuses?: ("streaming" | "finished" | "aborted")[];
}): Promise<StreamMessage[]>;
export type StreamingOptions = {
    /**
     * The minimum granularity of deltas to save.
     * Note: this is not a guarantee that every delta will be exactly one line.
     * E.g. if "line" is specified, it won't save any deltas until it encounters
     * a newline character.
     * Defaults to a regex that chunks by punctuation followed by whitespace.
     */
    chunking?: "word" | "line" | RegExp | ChunkDetector;
    /**
     * The minimum number of milliseconds to wait between saving deltas.
     * Defaults to 250.
     */
    throttleMs?: number;
};
export declare const DEFAULT_STREAMING_OPTIONS: {
    chunking: RegExp;
    throttleMs: number;
};
export declare function mergeTransforms<TOOLS extends ToolSet>(options: StreamingOptions | boolean | undefined, existing: StreamTextTransform<TOOLS> | Array<StreamTextTransform<TOOLS>> | undefined): StreamTextTransform<TOOLS> | StreamTextTransform<TOOLS>[] | undefined;
export declare class DeltaStreamer {
    #private;
    readonly component: AgentComponent;
    readonly ctx: RunActionCtx;
    readonly metadata: {
        threadId: string;
        agentName: string | undefined;
        model: string | undefined;
        provider: string | undefined;
        providerOptions: ProviderOptions | undefined;
        userId: string | undefined;
        order: number | undefined;
        stepOrder: number | undefined;
        abortSignal: AbortSignal | undefined;
    };
    streamId: string | undefined;
    readonly options: Required<StreamingOptions>;
    abortController: AbortController;
    constructor(component: AgentComponent, ctx: RunActionCtx, options: true | StreamingOptions, metadata: {
        threadId: string;
        agentName: string | undefined;
        model: string | undefined;
        provider: string | undefined;
        providerOptions: ProviderOptions | undefined;
        userId: string | undefined;
        order: number | undefined;
        stepOrder: number | undefined;
        abortSignal: AbortSignal | undefined;
    });
    addParts(parts: TextStreamPart[]): Promise<void>;
    finish(messages: MessageDoc[]): Promise<void>;
}
//# sourceMappingURL=streaming.d.ts.map