import type { Id } from "./_generated/dataModel.js";
import { type MutationCtx } from "./_generated/server.js";
import type { Infer } from "convex/values";
declare const addFileArgs: import("convex/values").VObject<{
    filename?: string | undefined;
    mimeType: string;
    storageId: string;
    hash: string;
}, {
    storageId: import("convex/values").VString<string, "required">;
    hash: import("convex/values").VString<string, "required">;
    filename: import("convex/values").VString<string | undefined, "optional">;
    mimeType: import("convex/values").VString<string, "required">;
}, "required", "mimeType" | "filename" | "storageId" | "hash">;
export declare const addFile: import("convex/server").RegisteredMutation<"public", {
    filename?: string | undefined;
    mimeType: string;
    storageId: string;
    hash: string;
}, Promise<{
    fileId: import("convex/values").GenericId<"files">;
    storageId: string;
}>>;
export declare function addFileHandler(ctx: MutationCtx, args: Infer<typeof addFileArgs>): Promise<{
    fileId: import("convex/values").GenericId<"files">;
    storageId: string;
}>;
export declare const get: import("convex/server").RegisteredQuery<"public", {
    fileId: import("convex/values").GenericId<"files">;
}, Promise<{
    _id: import("convex/values").GenericId<"files">;
    _creationTime: number;
    filename?: string | undefined;
    mimeType: string;
    storageId: string;
    hash: string;
    refcount: number;
    lastTouchedAt: number;
} | null>>;
/**
 * If you plan to have the same file added over and over without a reference to
 * the fileId, you can use this query to get the fileId of the existing file.
 * Note: this will not increment the refcount. only saving messages does that.
 * It will only match if the filename is the same (or both are undefined).
 */
export declare const useExistingFile: import("convex/server").RegisteredMutation<"public", {
    filename?: string | undefined;
    hash: string;
}, Promise<{
    fileId: import("convex/values").GenericId<"files">;
    storageId: string;
} | null>>;
export declare function changeRefcount(ctx: MutationCtx, prev: Id<"files">[], next: Id<"files">[]): Promise<void>;
export declare const copyFile: import("convex/server").RegisteredMutation<"public", {
    fileId: Id<"files">;
}, Promise<void>>;
export declare function copyFileHandler(ctx: MutationCtx, args: {
    fileId: Id<"files">;
}): Promise<void>;
/**
 * Get files that are unused and can be deleted.
 * This is useful for cleaning up files that are no longer needed.
 * Note: recently added files that have not been saved yet will show up here.
 * You can inspect the `lastTouchedAt` field to see how recently it was used.
 * I'd recommend not deleting anything touched in the last 24 hours.
 */
export declare const getFilesToDelete: import("convex/server").RegisteredQuery<"public", {
    paginationOpts: {
        id?: number | undefined;
        endCursor?: string | null | undefined;
        maximumRowsRead?: number | undefined;
        maximumBytesRead?: number | undefined;
        numItems: number;
        cursor: string | null;
    };
}, Promise<import("convex/server").PaginationResult<{
    _id: import("convex/values").GenericId<"files">;
    _creationTime: number;
    filename?: string | undefined;
    mimeType: string;
    storageId: string;
    hash: string;
    refcount: number;
    lastTouchedAt: number;
}>>>;
export declare const deleteFiles: import("convex/server").RegisteredMutation<"public", {
    force?: boolean | undefined;
    fileIds: import("convex/values").GenericId<"files">[];
}, Promise<import("convex/values").GenericId<"files">[]>>;
export {};
//# sourceMappingURL=files.d.ts.map